[{"categories":["源代码"],"content":"写在前面 本文将通过 Golang 源码研究其 HTTP Server 的核心实现。 研究对象主要是 Golang SDK net/http 包下的 server.go。 ","date":"2024-01-02","objectID":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/:1:0","tags":["Golang","HTTP","计算机网络"],"title":"源代码 —— Golang 中 HTTP Server 的设计","uri":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"categories":["源代码"],"content":"HTTP 应用工作模式 一个经典的基于 HTTP 协议的应用系统，其工作模式可以简单表示为以下流程： C-S 架构应用流程 具体来说，请求 Request 由客户端发出，服务端接收请求后，通过路由组件匹配到相应的处理器，处理器处理 Request 后构建 Response 返回给客户端。 ","date":"2024-01-02","objectID":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/:2:0","tags":["Golang","HTTP","计算机网络"],"title":"源代码 —— Golang 中 HTTP Server 的设计","uri":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"categories":["源代码"],"content":"Golang 中 HTTP Server 的核心实现 Golang HTTP Server 的核心实现也遵循上述基本流程 ","date":"2024-01-02","objectID":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/:3:0","tags":["Golang","HTTP","计算机网络"],"title":"源代码 —— Golang 中 HTTP Server 的设计","uri":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"categories":["源代码"],"content":"从一个 demo 入手 研究源码实现, 个人认为比较好的入手方式是写一个 demo，先跑起来~ package main import ( \"fmt\" \"net/http\" ) // 一种 http handler 的实现方式 func indexHandler(w http.ResponseWriter, r *http.Request) { fmt.printf(w, \"Hello World!\") } // 另一种实现方式 type otherIndexHandler struct { data string } func (ih *otherIndexHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { fmt.printf(w, ih.data) } func main() { // 第一种调用方式 http.HandleFunc(\"/\", indexHandler) http.ListenAndServe(\":8080\", nil) // 第二种调用方式 http.Handle(\"/\", \u0026otherIndexHandler{data: \"Hello World!\"}) http.ListenAndServe(\":8081\", nil); } 是的，这就实现了一个极简的 HTTP Server！ 简单分析一下这段代码：通过不同的方式定义 handler，并使用 Go 的标准库 http 注册 handler 到指定的路由，最后再启动对特定端口的监听。 第一种 handler 实现，indexHandler 是自定义的 handler，拥有 http.ResponseWriter 接口和 http.Request 结构体作为入参，函数实现非常简单，输出 “Hello World!\"。 第二种 handler 实现，我定义了一个 otherIndexHandler 结构体，并实现了 Go http 标准库中 Handler 接口的 ServeHTTP(ResponseWriter, *Request) 函数，因此，otherIndexHandler 就实现了 Handler 接口。 ","date":"2024-01-02","objectID":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/:3:1","tags":["Golang","HTTP","计算机网络"],"title":"源代码 —— Golang 中 HTTP Server 的设计","uri":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"categories":["源代码"],"content":"顺藤摸瓜 带着问题看源码，往往更有针对性，且不容易迷失在源码的各种分支细节里。 上述 demo 采用了两种方式启动一个 HTTP Server，有什么区别？ 第一种使用函数作为 handler，优点是简洁，适合简单逻辑；局限性是如果 handler 要维护状态或者访问其他字段，就必须使用全局变量或者闭包了。 第二种使用结构体实现 handler，可以很方便地为 handler 添加字段以存储状态或者其他数据、也可以定义很多方法，按照不同的路由或者请求类型进行处理，且有利于代码的组织和复用，局限性自然就是实现起来复杂些。 从软件工程复用性的角度考虑，底层标准库不太可能为上层应用做不同的实现，因此猜想 http.HandleFunc 和 http.Handle 最终的实现可能是一样的，甚至是同一个函数？ (1) http.HandleFunc 源码实现： var DefaultServeMux = \u0026defaultServeMux var defaultServeMux ServeMux func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) } func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(\"http: nil handler\") } // 调用 ServeMux 的 Handle 函数 mux.Handle(pattern, HandlerFunc(handler)) } (2) http.Handle 源码实现： func Handle(pattern string, handler Handler) { // DefaultServeMux 是 ServeMux 类型的指针 // 因此这也相当于调用 ServeMux 的 Handle 函数 DefaultServeMux.Handle(pattern, handler) } 可以看到，两种方式最终都是依赖了 ServeMux 的 Handle 函数，所以下一步重点是研究它。 需要注意的是，mux.Handle(pattern, HandlerFunc(handler)) 这行，因为 ServeMux.Handle 函数需要一个 Handler 接口类型的入参，因此这里使用了 HandlerFunc 将入参的 handler 转换为了 Handler 接口类型，具体原理可以在以下源码中看到： type Handler interface { ServeHTTP(ResponseWriter, *Request) } func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) } func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { if handler == nil { panic(\"http: nil handler\") } mux.Handle(pattern, HandlerFunc(handler)) } 这里其实运用了适配器设计模式，具体来说，其实是接口和类型的适配器模式，HandlerFunc 函数通过实现 ServeHTTP 方法，实现了 Handler 接口，再通过 HandlerFunc(handler) 将普通函数 handler 转为 Handler 这个接口类型。这是 Go 语言中接口的一种常见用法：通过定义函数类型并为该类型实现接口，我们可以将其他函数通过类型转换特性，转作接口类型的值来使用，从而实现了函数和接口类型之间的适配。 ServeMux 是什么？ ServeMux 是一个很重要的结构体 —— HTTP 请求的多路复用器（Multiplexer，也常被称为 Mux），作用是将传入的请求 URL 与预定义的模式列表做匹配，并将匹配成功的请求分发给相应的处理函数 (handler) type ServeMux struct { mu sync.RWMutex m map[string]muxEntry es []muxEntry hosts bool } type muxEntry struct { h Handler pattern string } mu 是一个读写器互斥锁，该锁可以由任意数量的读取器或单个写入器持有，这里非本文主线，不展开其实现细节，知道特性就行。 m 是一个 map，其元素是结构体类型 muxEntry，负责保存 pattern 和对应 handler 的映射关系。 es 是一个切片，它存储了所有的路由规则并按照一定规则进行排序。 ServeMux.Handle 函数的工作流程是什么？ 源码如下： func (mux *ServeMux) Handle(pattern string, handler Handler) { mux.mu.Lock() defer mux.mu.Unlock() if pattern == \"\" { panic(\"http: invalid pattern\") } if handler == nil { panic(\"http: nil handler\") } if _, exist := mux.m[pattern]; exist { panic(\"http: multiple registrations for \" + pattern) } if mux.m == nil { mux.m = make(map[string]muxEntry) } e := muxEntry{h: handler, pattern: pattern} mux.m[pattern] = e if pattern[len(pattern)-1] == '/' { mux.es = appendSorted(mux.es, e) } if pattern[0] != '/' { mux.hosts = true } } func appendSorted(es []muxEntry, e muxEntry) []muxEntry { n := len(es) // 使用 sort.Search 函数查找 muxEntry 应该插入的位置。 // sort.Search 函数接受一个长度 n 和一个函数 f，并返回满足 f(i) 为真的最小的 i。 // 在这里，f(i) 函数检查 es[i].pattern 的长度是否小于 e.pattern 的长度。 // 这个搜索过程是二分搜索，所以时间复杂度为O(log n)。 i := sort.Search(n, func(i int) bool { return len(es[i].pattern) \u003c len(e.pattern) }) // 如果应插入的位置 i 等于切片的长度 n，说明 e 应该被插入到切片的尾部 // 那就直接使用 append 函数将 e 添加到切片的尾部并返回结果 if i == n { return append(es, e) } // 如果应插入的位置 i 小于切片的长度 n，说明 e 应该被插入到切片的中间位置。 // 首先，使用 append 函数将一个空的 muxEntry 添加到切片的尾部，让切片的长度增加 1。 // 然后，使用 copy 函数将 i 位置及之后的元素向后移动一位，为插入 e 腾出空间。 // 最后，将 e 复制到 i 位置。 es = append(es, muxEntry{}) copy(es[i+1:], es[i:]) es[i] = e return es } 源码逻辑比较简单： 先加读写互斥锁，保证对 ServeMux.mu 和 ServeMux.m 的并发读写操作是线程安全的，避免数据不一致或者数据竞态等问题。 接下来是一些校验，这里有一个逻辑，mux.m 不支持对同一个模式（pattern）重复注册 Handler，这里有一个编码技巧：对 exist 的判断和对 mux.m == nil 的判断逻辑的先后顺序，从结果上来说，这两块逻辑可以调换，不会有问题，标准库这里实现的优化是：如果 pattern 已经存在于 mux.m 中，就没必要再创建一个新的 map 了。 接下来创建一个新的 muxEntry，将传入的 handler 和 pattern 映射写入；接着检查传入的模式字符串 pattern 是否以 / 字符结束，如果是，则通过 appendSorted 函数将这个新的 muxEntry 插入到 mux.es 切片的合适位置，以保持切片的排序顺序（appendSorted 的实现逻辑见上方注释）。从 appendSorted 函数的实现也可以确认，es 中 pattern 长度是逐渐递减的，即 mux 对 pattern 的匹配遵循最长匹配原则，而不是精准匹配，这样好处是比较灵活，尤其是对 RESTful 风格的 API 设计比较友好，可以更灵活地处理复杂的 URL 结构。 注册路由 Handler 的流程到此告一段落。 接下来看看启动服务的流","date":"2024-01-02","objectID":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/:3:2","tags":["Golang","HTTP","计算机网络"],"title":"源代码 —— Golang 中 HTTP Server 的设计","uri":"/%E6%BA%90%E4%BB%A3%E7%A0%81-golang-%E4%B8%AD-http-server-%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机网络"],"content":"写在前面 聊起 HTTP，总有一种熟悉又陌生的感觉。 HTTP 是每天都在打交道的基础网络组件。但中文网络上大多内容都是面向面试的… 系统性内容较少，相关知识也比较零碎。 本文不是大而全的 HTTP 手册（大概率也没法覆盖全貌），也不针对技术面试，旨在梳理 HTTP 协议的基本框架，建立整体认知。 ","date":"2023-12-29","objectID":"/%E8%81%8A%E8%81%8A-http/:1:0","tags":["网络"],"title":"聊聊 HTTP","uri":"/%E8%81%8A%E8%81%8A-http/"},{"categories":["计算机网络"],"content":"HTTP 概念 HTTP 是一种 C-S（client-server） 架构的网络通信协议。 ","date":"2023-12-29","objectID":"/%E8%81%8A%E8%81%8A-http/:2:0","tags":["网络"],"title":"聊聊 HTTP","uri":"/%E8%81%8A%E8%81%8A-http/"},{"categories":["计算机网络"],"content":"概念 HTTP（HyperText Transfer Protocol，超文本传输协议），顾名思义，它是被设计为在互联网计算机间传输超文本的一种通信协议，也可以说是一种规范。 HTTP 发展至今，已经不仅局限于传输超文本，图片、视频、HTML 表单等等均可以通过 HTTP 传输。HTTP 是互联网的 “神经”，是最重要的基础设施。 ","date":"2023-12-29","objectID":"/%E8%81%8A%E8%81%8A-http/:2:1","tags":["网络"],"title":"聊聊 HTTP","uri":"/%E8%81%8A%E8%81%8A-http/"},{"categories":["计算机网络"],"content":"HTTP 组件 HTTP 协议起指导作用。通过建立各种网络组件，指导组件间的协作，共同完成网络数据在计算机节点间的传输。 HTTP 组件 ","date":"2023-12-29","objectID":"/%E8%81%8A%E8%81%8A-http/:3:0","tags":["网络"],"title":"聊聊 HTTP","uri":"/%E8%81%8A%E8%81%8A-http/"},{"categories":["计算机网络"],"content":"客户端 客户端即客户代理，是 HTTP 请求的发出方，通常是浏览器或者网络请求代码。 只有客户端会发出请求（Request），服务端不会（随着发展，已经有机制可以在服务端模拟发出消息）。 客户端发出请求后，接收服务端响应（Response）并解析响应的内容，以便进行下一步处理（呈现在浏览器或者对数据进行再处理）。 ","date":"2023-12-29","objectID":"/%E8%81%8A%E8%81%8A-http/:3:1","tags":["网络"],"title":"聊聊 HTTP","uri":"/%E8%81%8A%E8%81%8A-http/"},{"categories":["计算机网络"],"content":"Proxys 请求发出后，实际还需要经过路由器、网关等诸多环节才能到达服务端。 Web 架构是分层的，请求传递的大多操作都在传输层、网络层或物理层，这些层对于 HTTP 应用层基本上透明的。也会对网络性能产生重要影响。 Proxys 大多在应用层参与消息传递，且不一定是透明的（有些代理可能会对请求消息内容进行修改，有的则不会）。 Proxys 可以发挥如负载均衡、流量清洗、缓存、鉴权等等作用。 ","date":"2023-12-29","objectID":"/%E8%81%8A%E8%81%8A-http/:3:2","tags":["网络"],"title":"聊聊 HTTP","uri":"/%E8%81%8A%E8%81%8A-http/"},{"categories":["计算机网络"],"content":"服务端 服务端可以提供客户端所请求的数据，通常是一个计算机或者多个共享负载的计算机组成的服务集群，这些计算机通常会运行开发者构建的各种软件，以此向客户端提供多样的互联网服务。 ","date":"2023-12-29","objectID":"/%E8%81%8A%E8%81%8A-http/:3:3","tags":["网络"],"title":"聊聊 HTTP","uri":"/%E8%81%8A%E8%81%8A-http/"},{"categories":["计算机网络"],"content":"HTTP 基本性质 简单可扩展：协议简单。HTTP Header 也支持方便地对协议进行扩展。 无状态但不一定无会话：无状态是指：同一个连接中，多个请求是没有关系的。有状态的会话能力可以借助 HTTP Cookie 实现 —— Cookie 也是利用 Header 的扩展性添加进协议流程的，它使得多次请求可以共享相同的上下文信息或状态。解决了 HTTP 协议无状态带来的一些问题。 HTTP 和网络连接：网络连接通常由传输层控制。HTTP 不要求传输层协议是面向连接的，只需要 可靠 即可。TCP 是可靠的，UDP 不是，因此 HTTP 建立在 TCP 标准上。不过在发展过程中，出现了一种新的传输层协议 —— QUIC（Google 提出），它建立在 UDP 之上。 ","date":"2023-12-29","objectID":"/%E8%81%8A%E8%81%8A-http/:4:0","tags":["网络"],"title":"聊聊 HTTP","uri":"/%E8%81%8A%E8%81%8A-http/"},{"categories":["计算机网络"],"content":"HTTP 连接问题 HTTP 是基于 TCP 可靠连接的，因此建立 HTTP 连接的过程，其实就是使用三次 TCP 握手的过程。 TCP 三次握手 ","date":"2023-12-29","objectID":"/%E8%81%8A%E8%81%8A-http/:5:0","tags":["网络"],"title":"聊聊 HTTP","uri":"/%E8%81%8A%E8%81%8A-http/"},{"categories":[],"content":"为什么想做博客~ 我在互联网做技术，也算大厂。但每天的工作内容比较枯燥。 国内的商业公司，经营利润和业务发展大多摆在极重要的位置。个人觉得，大多时候技术相对不那么受关注（国外公司不清楚，不瞎说），每天开会比较多，为了支持业务快速发展，很多技术同学也都是抱着 “能用就行，先上线” 的心态，技术气氛比较浮躁… 最初决定做技术，心里是比较纯粹的（现在也是～）。我相信技术本身有自己独特的价值和魅力。这也是我的一大爱好，发现问题，解决问题的感觉真的很酷！ 一直想做内容积累，但因为各种理由都没能真正开始，最近刚好有些想法，想着可能是个契机，就动手了。 为什么是辜月 辜者，故也，亦有 \" 吐故纳新 \" 之意。 癸卯年辜月有了做这个博客的想法，就定了这个有些随意的名字，但我很喜欢。 会写些什么 计算机领域，一些常见技术问题，希望能深入讨论 生产中一些老生常谈的话题或技术方案，希望用新的视角来看 偶尔有些想法或者看法，也会记录下 ","date":"2023-12-27","objectID":"/%E7%BC%98%E7%94%B1%E4%BA%A6%E6%88%96%E7%BC%98%E8%B5%B7/:0:0","tags":["动念"],"title":"缘由，亦或缘起","uri":"/%E7%BC%98%E7%94%B1%E4%BA%A6%E6%88%96%E7%BC%98%E8%B5%B7/"}]